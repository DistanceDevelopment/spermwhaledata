output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
knitr::kable(collect.models)$table
knitr::kable(collect.models()$table)
fred <- collect.models()$table
fred
fred <- collect.models()
str(fred)
knitr::kable(collect.models()$model.table)
make.covar.history <- function(N=100, beta=log(0.05), beta1=log(12), sigma.p=0.1, n.occ=10) {
pvec <- vector(mode="numeric", length=N)
ave.wt <- vector(mode="numeric", length=N)
average.wt <- runif(N, 0, 1)
for (i in 1:N) {   # capture heterogeneous probabilities
pvec[i] <- 1/(1+exp(-(beta + beta1*average.wt[i] + sigma.p * rnorm(1,0,1))))
}
plot(average.wt, pvec)
cap.hist <- matrix(data = rep(0, N*n.occ), nrow = N)
caught <- 1
for (i in 1:N) {  # capture histories based on hetergeneous probs.
chances <- runif(n.occ,0,1)
ch <- ifelse(pvec[i]<chances, 0, 1)
if (sum(ch)>0) {
cap.hist[caught, ] <- ch
caught <- caught + 1
ave.wt[i] <- average.wt[i] # keep only weights of captured animals
}
}
observed <- cap.hist[1:caught-1, ]
grind <- data.frame(ch=collapseCH(chmat = observed), ave.wt=ave.wt[1:(caught-1)],
stringsAsFactors = FALSE)
return(grind)
}
fake.data <- make.covar.history()
fake.data$ncapt <- rowSums(splitCH(fake.data$ch))
plot(fake.data$ncapt~fake.data$ave.wt)
m.wt <- mark(fake.data, model="Huggins", model.parameters=list(p=p.function.of.wght),
output = FALSE, silent=TRUE, delete = TRUE)
m0<- mark(fake.data,model="Huggins",model.parameters=list(p=M0),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mb <- mark(fake.data,model="Huggins",model.parameters=list(p=Mb),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mt <- mark(fake.data,model="Huggins",model.parameters=list(p=Mt),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mh <- mark(fake.data,model="HugHet",model.parameters=list(p=Mh),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mtb <- mark(fake.data,model="Huggins",model.parameters=list(p=Mtb),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mbh <- mark(fake.data,model="HugFullHet",model.parameters=list(p=Mbh),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mth <- mark(fake.data,model="HugFullHet",model.parameters=list(p=Mth),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
knitr::kable(collect.models()$model.table)
mh$results$derived
m.wt$results$derived
mh$results$real
ls(pattern="^hug")
show.solution <- FALSE
library(RMark)
data(edwards.eberhardt)
M0 <- list(formula=~1,share=TRUE)
Mb <- list(formula=~1, share=FALSE)
Mt <- list(formula=~time,share=TRUE)
Mh <- list(formula=~mixture)
Mtb <- list(formula=~time+c,share=TRUE)
Mbh <- list(formula=~mixture+c, share=TRUE)
Mth <- list(formula=~time+mixture,share=TRUE)
hug.m0.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=M0),
output=FALSE, se=FALSE, delete = TRUE)
hug.mb.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mb),
output=FALSE, se=FALSE, delete = TRUE)
hug.mt.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mt),
output=FALSE, se=FALSE, delete = TRUE)
hug.mh.estimates <- mark(edwards.eberhardt,model="HugHet",model.parameters=list(p=Mh),
output=FALSE, se=FALSE, delete = TRUE)
hug.mtb.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mtb),
output=FALSE, se=FALSE, delete = TRUE)
hug.mbh.estimates <- mark(edwards.eberhardt,model="HugFullHet",model.parameters=list(p=Mbh),
output=FALSE, se=FALSE, delete = TRUE)
hug.mth.estimates <- mark(edwards.eberhardt,model="HugFullHet",model.parameters=list(p=Mth),
output=FALSE, se=FALSE, delete = TRUE)
knitr::kable(collect.models()$model.table, digits=c(0,0,0,1,1,2,0))
str(hug.m0.estimates, max.level=1)
knitr::kable(hug.mtb.estimates$results$beta[c(1,16,19),], digits=c(2,2,2,2,2))
rm(list = ls(pattern="^hug"))
occasions <- 1:18
pvalues <- get.real(hug.mth.estimates, "p")[[1]]
show.solution <- FALSE
library(RMark)
data(edwards.eberhardt)
M0 <- list(formula=~1,share=TRUE)
Mb <- list(formula=~1, share=FALSE)
Mt <- list(formula=~time,share=TRUE)
Mh <- list(formula=~mixture)
Mtb <- list(formula=~time+c,share=TRUE)
Mbh <- list(formula=~mixture+c, share=TRUE)
Mth <- list(formula=~time+mixture,share=TRUE)
hug.m0.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=M0),
output=FALSE, se=FALSE, delete = TRUE)
hug.mb.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mb),
output=FALSE, se=FALSE, delete = TRUE)
hug.mt.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mt),
output=FALSE, se=FALSE, delete = TRUE)
hug.mh.estimates <- mark(edwards.eberhardt,model="HugHet",model.parameters=list(p=Mh),
output=FALSE, se=FALSE, delete = TRUE)
hug.mtb.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mtb),
output=FALSE, se=FALSE, delete = TRUE)
hug.mbh.estimates <- mark(edwards.eberhardt,model="HugFullHet",model.parameters=list(p=Mbh),
output=FALSE, se=FALSE, delete = TRUE)
hug.mth.estimates <- mark(edwards.eberhardt,model="HugFullHet",model.parameters=list(p=Mth),
output=FALSE, se=FALSE, delete = TRUE)
knitr::kable(collect.models()$model.table, digits=c(0,0,0,1,1,2,0))
str(hug.m0.estimates, max.level=1)
knitr::kable(hug.mtb.estimates$results$beta[c(1,16,19),], digits=c(2,2,2,2,2))
occasions <- 1:18
pvalues <- get.real(hug.mth.estimates, "p")[[1]]
pi.value <- get.real(hug.mth.estimates, "pi")[[1]]
yrange <- range(pvalues)
plot(occasions, pvalues[1,], type="l", lwd=2, main="Cottontails, M(th)",
xlab="Capture occasion", ylab="Probability of capture", ylim=yrange)
lines(occasions, pvalues[2,], lwd=2, lty=3)
leg.title <- paste("Pr(Group=1)=", round(pi.value,3))
n.t <- unname(colSums(splitCH(edwards.eberhardt$ch)))  # number caught each occasion
text(occasions, -0.005, n.t, cex=0.6)
legend("topright", title=leg.title, legend=c("Pr(Capture|Group 1)", "Pr(Capture|Group 2)"),
lwd=2, lty=c(1,3))
abundance <- round(hug.mth.estimates$results$derived$`N Population Size`,1)
rm(list = ls(pattern="^hug")) # finished with rabbit analysis
abundance <- round(hug.mth.estimates$results$derived$`N Population Size`,1)
show.solution <- FALSE
library(RMark)
data(edwards.eberhardt)
M0 <- list(formula=~1,share=TRUE)
Mb <- list(formula=~1, share=FALSE)
Mt <- list(formula=~time,share=TRUE)
Mh <- list(formula=~mixture)
Mtb <- list(formula=~time+c,share=TRUE)
Mbh <- list(formula=~mixture+c, share=TRUE)
Mth <- list(formula=~time+mixture,share=TRUE)
hug.m0.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=M0),
output=FALSE, se=FALSE, delete = TRUE)
hug.mb.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mb),
output=FALSE, se=FALSE, delete = TRUE)
hug.mt.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mt),
output=FALSE, se=FALSE, delete = TRUE)
hug.mh.estimates <- mark(edwards.eberhardt,model="HugHet",model.parameters=list(p=Mh),
output=FALSE, se=FALSE, delete = TRUE)
hug.mtb.estimates <- mark(edwards.eberhardt,model="Huggins",model.parameters=list(p=Mtb),
output=FALSE, se=FALSE, delete = TRUE)
hug.mbh.estimates <- mark(edwards.eberhardt,model="HugFullHet",model.parameters=list(p=Mbh),
output=FALSE, se=FALSE, delete = TRUE)
hug.mth.estimates <- mark(edwards.eberhardt,model="HugFullHet",model.parameters=list(p=Mth),
output=FALSE, se=FALSE, delete = TRUE)
knitr::kable(collect.models()$model.table, digits=c(0,0,0,1,1,2,0))
str(hug.m0.estimates, max.level=1)
knitr::kable(hug.mtb.estimates$results$beta[c(1,16,19),], digits=c(2,2,2,2,2))
occasions <- 1:18
pvalues <- get.real(hug.mth.estimates, "p")[[1]]
pi.value <- get.real(hug.mth.estimates, "pi")[[1]]
yrange <- range(pvalues)
plot(occasions, pvalues[1,], type="l", lwd=2, main="Cottontails, M(th)",
xlab="Capture occasion", ylab="Probability of capture", ylim=yrange)
lines(occasions, pvalues[2,], lwd=2, lty=3)
leg.title <- paste("Pr(Group=1)=", round(pi.value,3))
n.t <- unname(colSums(splitCH(edwards.eberhardt$ch)))  # number caught each occasion
text(occasions, -0.005, n.t, cex=0.6)
legend("topright", title=leg.title, legend=c("Pr(Capture|Group 1)", "Pr(Capture|Group 2)"),
lwd=2, lty=c(1,3))
abundance <- round(hug.mth.estimates$results$derived$`N Population Size`,1)
rm(list = ls(pattern="^hug")) # finished with rabbit analysis
make.covar.history <- function(N=100, beta=log(0.05), beta1=log(12), sigma.p=0.1, n.occ=10) {
pvec <- vector(mode="numeric", length=N)
ave.wt <- vector(mode="numeric", length=N)
average.wt <- runif(N, 0, 1)
for (i in 1:N) {   # capture heterogeneous probabilities
pvec[i] <- 1/(1+exp(-(beta + beta1*average.wt[i] + sigma.p * rnorm(1,0,1))))
}
plot(average.wt, pvec, xlab="Weight covariate", ylab="Capture probability",
main="True covariate relationship")
cap.hist <- matrix(data = rep(0, N*n.occ), nrow = N)
caught <- 1
for (i in 1:N) {  # capture histories based on hetergeneous probs.
chances <- runif(n.occ,0,1)
ch <- ifelse(pvec[i]<chances, 0, 1)
if (sum(ch)>0) {
cap.hist[caught, ] <- ch
ave.wt[caught] <- average.wt[i] # keep only weights of captured animals
caught <- caught + 1
}
}
observed <- cap.hist[1:caught-1, ]
grind <- data.frame(ch=collapseCH(chmat = observed), ave.wt=ave.wt[1:(caught-1)],
stringsAsFactors = FALSE)
return(grind)
}
fake.data <- make.covar.history(beta1 = log(30), sigma.p = 0)
p.function.of.wght <- list(formula=~ave.wt, share=TRUE)
m.wt <- mark(fake.data, model="Huggins", model.parameters=list(p=p.function.of.wght),
output = FALSE, silent=TRUE, delete = TRUE)
m0<- mark(fake.data,model="Huggins",model.parameters=list(p=M0),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mb <- mark(fake.data,model="Huggins",model.parameters=list(p=Mb),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mt <- mark(fake.data,model="Huggins",model.parameters=list(p=Mt),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mh <- mark(fake.data,model="HugHet",model.parameters=list(p=Mh),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mtb <- mark(fake.data,model="Huggins",model.parameters=list(p=Mtb),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mbh <- mark(fake.data,model="HugFullHet",model.parameters=list(p=Mbh),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
mth <- mark(fake.data,model="HugFullHet",model.parameters=list(p=Mth),
output=FALSE, se=FALSE, silent=TRUE, delete = TRUE)
knitr::kable(collect.models()$model.table)
new.data <- data.frame(ave.wt=seq(0,1,0.01))
#just p[1] because not time specific..
p.hat.cov <- covariate.predictions(m.wt,data=new.data,indices=c(1))
plot(new.data$ave.wt, p.hat.cov$estimates$estimate, ylim=c(0,1))
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$lcl,lty=2)
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$ucl,lty=2)
new.data <- data.frame(ave.wt=seq(0,1,0.01))
#just p[1] because not time specific..
p.hat.cov <- covariate.predictions(m.wt,data=new.data,indices=c(1))
plot(new.data$ave.wt, p.hat.cov$estimates$estimate, ylim=c(0,1),
xlab="Covariate average weight", ylab="Capture probability",
main="Estimated covariate relationship")
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$lcl,lty=2)
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$ucl,lty=2)
text(0.1, 0.8, pos=2,
bquote(hat(beta_0)==.(round(m.wt$results$beta$estimate[1],3))))
text(0.2, 0.8, pos=2,
substitute(paste("SE(",hat(beta_0),")=", se),
list(se=round(sqrt(m.wt$results$beta.vcv[1,1]),4))))
?text
new.data <- data.frame(ave.wt=seq(0,1,0.01))
#just p[1] because not time specific..
p.hat.cov <- covariate.predictions(m.wt,data=new.data,indices=c(1))
plot(new.data$ave.wt, p.hat.cov$estimates$estimate, ylim=c(0,1),
xlab="Covariate average weight", ylab="Capture probability",
main="Estimated covariate relationship")
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$lcl,lty=2)
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$ucl,lty=2)
text(0.1, 0.8, pos=4,
bquote(hat(beta_0)==.(round(m.wt$results$beta$estimate[1],3))))
text(0.2, 0.8, pos=4,
substitute(paste("SE(",hat(beta_0),")=", se),
list(se=round(sqrt(m.wt$results$beta.vcv[1,1]),4))))
new.data <- data.frame(ave.wt=seq(0,1,0.01))
#just p[1] because not time specific..
p.hat.cov <- covariate.predictions(m.wt,data=new.data,indices=c(1))
plot(new.data$ave.wt, p.hat.cov$estimates$estimate, ylim=c(0,1),
xlab="Covariate average weight", ylab="Capture probability",
main="Estimated covariate relationship")
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$lcl,lty=2)
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$ucl,lty=2)
text(0.1, 0.8, pos=4,
bquote(hat(beta)==.(round(m.wt$results$beta$estimate[1],3))))
text(0.2, 0.8, pos=4,
substitute(paste("SE(",hat(beta),")=", se),
list(se=round(sqrt(m.wt$results$beta.vcv[1,1]),4))))
new.data <- data.frame(ave.wt=seq(0,1,0.01))
#just p[1] because not time specific..
p.hat.cov <- covariate.predictions(m.wt,data=new.data,indices=c(1))
plot(new.data$ave.wt, p.hat.cov$estimates$estimate, ylim=c(0,1),
xlab="Covariate average weight", ylab="Capture probability",
main="Estimated covariate relationship")
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$lcl,lty=2)
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$ucl,lty=2)
text(0.1, 0.8, pos=4,
bquote(hat(beta)==.(round(m.wt$results$beta$estimate[1],3))))
text(0.25, 0.8, pos=4,
substitute(paste("SE(",hat(beta),")=", se),
list(se=round(sqrt(m.wt$results$beta.vcv[1,1]),4))))
?bquote
?plotmath
new.data <- data.frame(ave.wt=seq(0,1,0.01))
#just p[1] because not time specific..
p.hat.cov <- covariate.predictions(m.wt,data=new.data,indices=c(1))
plot(new.data$ave.wt, p.hat.cov$estimates$estimate, ylim=c(0,1),
xlab="Covariate average weight", ylab="Capture probability",
main="Estimated covariate relationship")
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$lcl,lty=2)
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$ucl,lty=2)
text(0.1, 0.8, pos=4,
bquote(hat(beta[0])==.(round(m.wt$results$beta$estimate[1],3))))
text(0.25, 0.8, pos=4,
substitute(paste("SE(",hat(beta[0]),")=", se),
list(se=round(sqrt(m.wt$results$beta.vcv[1,1]),4))))
new.data <- data.frame(ave.wt=seq(0,1,0.01))
#just p[1] because not time specific..
p.hat.cov <- covariate.predictions(m.wt,data=new.data,indices=c(1))
plot(new.data$ave.wt, p.hat.cov$estimates$estimate, ylim=c(0,1),
xlab="Covariate average weight", ylab="Capture probability",
main="Estimated covariate relationship")
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$lcl,lty=2)
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$ucl,lty=2)
text(0.1, 0.8, pos=4,
bquote(widehat(beta[0])==.(round(m.wt$results$beta$estimate[1],3))))
text(0.25, 0.8, pos=4,
substitute(paste("SE(",widehat(beta[0]),")=", se),
list(se=round(sqrt(m.wt$results$beta.vcv[1,1]),4))))
new.data <- data.frame(ave.wt=seq(0,1,0.01))
#just p[1] because not time specific..
p.hat.cov <- covariate.predictions(m.wt,data=new.data,indices=c(1))
plot(new.data$ave.wt, p.hat.cov$estimates$estimate, ylim=c(0,1),
xlab="Covariate average weight", ylab="Capture probability",
main="Estimated covariate relationship")
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$lcl,lty=2)
lines(p.hat.cov$estimates$covdata, p.hat.cov$estimates$ucl,lty=2)
text(0.1, 0.8, pos=4,
bquote(widehat(beta[0])==.(round(m.wt$results$beta$estimate[1],3))))
text(0.25, 0.8, pos=4,
substitute(paste("SE(",widehat(beta[0]),")=", se),
list(se=round(sqrt(m.wt$results$beta.vcv[1,1]),4))))
text(0.1, 0.6, pos=4,
bquote(widehat(beta[1])==.(round(m.wt$results$beta$estimate[2],3))))
text(0.25, 0.6, pos=4,
substitute(paste("SE(",widehat(beta[1]),")=", se),
list(se=round(sqrt(m.wt$results$beta.vcv[2,2]),4))))
round(log(m.wt$results$beta$estimate[2]),3)
round(log(m.wt$results$beta$estimate[1]),3)
m.wt$results$beta$estimate[1]
log(m.wt$results$beta$estimate[1])
exp(m.wt$results$beta$estimate[1])
round(exp(m.wt$results$beta$estimate[1]),3)
round(log(m.wt$results$beta$estimate[2]),3)
round(exp(m.wt$results$beta$estimate[2]),3)
library(RMark, quietly=TRUE)
load("swtdat.rda")
swal <- process.data(swtdat, model="Occupancy")
p.dot <- list(formula=~1)
p.duration <- list(formula=~dur)
p.intensity <- list(formula=~intensity)
p.day <- list(formula=~day)
p.dur.day <- list(formula=~dur+day)
p.dur.x.day <- list(formula=~dur*day)
Psi.dot <- list(formula=~1)
Psi.elev <- list(formula=~elev)
Psi.elev2 <- list(formula=~elev+elevsq)
Psi.forest <- list(formula=~forest)
Psi.for.elev2 <- list(formula=~forest+(elev+elevsq))
Psi.for.x.elev2 <- list(formula=~forest*(elev+elevsq))
mylist <- create.model.list("Occupancy")
results <- mark.wrapper(mylist, data=swal, silent=TRUE, output=FALSE)
kable(results$model.table[,1:6], row.names=FALSE, digits=2,
caption="Models for Swiss willow tits")
library(knitr)
kable(results$model.table[,1:6], row.names=FALSE, digits=2,
caption="Models for Swiss willow tits")
?mark.wrapper
?mark.wrapper.parallel
obs.elev <- range(swtdat$elev)
elev.vals <- seq(obs.elev[1], obs.elev[2], length=50)
for.vals <- seq(0,1, length=25)
predict.frame <- expand.grid(elev.vals, for.vals)
names(predict.frame) <- c("elev", "forest")
predict.frame$elevsq <- predict.frame$elev^2
psi.predict <- covariate.predictions(results$p.duration.Psi.for.x.elev2,
data=predict.frame,
indices=c(4)) # see function PIMS()
mean.elev <- 1152.4 # from handout
uM = matrix(c(0.83, -0.08, 0.54, 0, 0.54, 0.21, -0.81, 0, -0.04, 0.97, 0.22, 0, 0, 0, 0, 1), 4, 4)
library(rgl)
open3d(userMatrix = uM, windowRect = c(0, 0, 600, 600))
bg3d("white")
material3d(col="black")
persp3d(elev.vals+mean.elev, for.vals, psi.predict$estimates$estimate,
aspect=c(1,1,0.5), col="lightblue", forceClipregion=TRUE,
xlab="Elevation (m)", ylab="Forest (%)", zlab="Psi-hat",
#        main="Estimated occupancy, with point-wise CI",
sub="Model: p(duration) Psi(forest*(elev+elev2)")
persp3d(elev.vals+mean.elev, for.vals, psi.predict$estimates$lcl, col="yellow",
aspect=c(1,1,0.5), add=TRUE)
persp3d(elev.vals+mean.elev, for.vals, psi.predict$estimates$ucl, col="yellow",
aspect=c(1,1,0.5), add=TRUE)
rgl.snapshot("picture.png" )
kable(results$p.duration.Psi.for.x.elev2$results$beta, digits=5,
caption="Parameter estimates (on logit scale) for p(duration) Psi(forest*(quadratic elevation))")
source('P:/pCloud Sync/MT5751/practicals/occdesign1sp.R', echo=TRUE)
0
evaldesign()
myres<-evaldesign(psi=0.2,p=0.3,s=62,k=4,nits=1000,doprint=1,doplot=1)
myres<-evaldesign(psi=0.2,p=0.3,s=62,k=4,nits=10000,doprint=1,doplot=1)
myres<-evaldesign(psi=0.2,p=0.3,s=62,k=4,nits=100000,doprint=1,doplot=1)
myres<-evaldesign(psi=0.2,p=0.3,s=62,k=4,nits=1000000,doprint=1,doplot=1)
load("C:/Users/eric/Dropbox/apps/Pancake.io/scr-stand2016/prac2-spatial/survey-objects.RData")
View(kruger.mask)
attr(kruger.mask)
str(kruger.mask)
getwd()
save(kruger.mask, "prac7-mask-covars.RData")
save(kruger.mask, file="prac7-mask-covars.RData")
2154*150
ob <- hist(runif(100))
str(ob)
max(ob$counts)
log(.5)
knitr::opts_chunk$set(echo = TRUE)
make.het.distrib <- function(N=100, beta=log(0.1),
sigma.p=0.1, n.occ=5) {
pvec <- vector(mode="numeric", length=N)
for (i in 1:N) {   # capture heterogeneous probabilities
pvec[i] <- 1/(1+exp(-(beta + sigma.p * rnorm(1,0,1))))
}
my.title <- paste("p=", exp(beta), "sigma.p=", sigma.p)
my.breaks <- seq(from=0, to=1, by=.02)
hist.stuff <- hist(pvec, main=my.title, breaks=my.breaks, xlim=c(0,1))
abline(v=mean(pvec), lty=3, lwd=2)
text(0.8, 0.9*max(hist.stuff$counts), round(mean(pvec),2), cex=0.8)
}
make.het.distrib(beta=log(0.5), sigma.p=0)
1/(1+exp(-.5))
1/(1+exp(-log(.5)))
1/(1+exp(-log(.1)))
1/(1+exp(-log(.7)))
1/(1+exp(-log(.8)))
1/(1+exp(-log(.9)))
1/(1+exp(-log(1.1)))
1/(1+exp(-log(1.)))
1/(1+exp(-log(.12)))
1/(1+exp(-log(.11)))
1/(1+exp(-log(.111)))
1/(1+exp(-log(.1111)))
1-(1-p)^5
p <- .2
1-(1-p)^5
p <- .1
1-(1-p)^5
p <- .05
1-(1-p)^5
p <- .01
1-(1-p)^5
1600/60
library(DSsim)
DSsim:::summary
DSsim::summary
install.packages("statmod")
load("P:/pCloud Sync/MT5751/practicals/prac7-mask-covars.RData")
cell.spacing <- attr(kruger.mask, "spacing")
calc.cell.area <- cell.spacing^2 / 10000
given.cell.area <- attr(kruger.mask, "area")
print(paste("Calculated cell area", round(calc.cell.area),
"Given cell area", round(given.cell.area), sep=" "))
loglinear.fit <- secr.fit(capthist = all.data, mask = kruger.mask, detectfn = "HHN",
model = list(D ~ habitat.cov), trace=FALSE)
library(secr)
loglinear.fit <- secr.fit(capthist = all.data, mask = kruger.mask, detectfn = "HHN",
model = list(D ~ habitat.cov), trace=FALSE)
library(secr)
all.data <- read.capthist(captfile="krug-countcapt.txt",
trapfile="krug-counttrap.txt",
detector="count", fmt="trapID",
trapcovnames=c("sname","habitat.cov","landscape",
"water","high.water","dist.to.water"))
gam.fit <- secr.fit(capthist = all.data, mask = kruger.mask, detectfn = "HHN",
model = list(D ~ s(x, y, k = 4)), trace = FALSE)
loglinear.fit <- secr.fit(capthist = all.data, mask = kruger.mask, detectfn = "HHN",
model = list(D ~ habitat.cov), trace=FALSE)
spline.fit <- secr.fit(capthist = all.data, mask = kruger.mask, detectfn = "HHN",
model = list(D ~ s(habitat.cov, k = 3)), trace=FALSE)
simple.fit <- secr.fit(capthist = all.data, mask = kruger.mask, detectfn = "HHN",
model = list(D ~ 1), trace=FALSE)
## Many options. Here is one:
water.fit <- secr.fit(capthist = all.data, mask = kruger.mask, detectfn = "HHN",
model = list(D ~ habitat.cov + dist.to.water), start = loglinear.fit,
trace=FALSE)
## This model seemed to have problems finding the MLE; I've used start values from
## loglinear.fit to get around this.
large.table <- AIC(loglinear.fit, simple.fit,  spline.fit, gam.fit)
knitr::kable(large.table[c(1,6,7)])
large.table
plot(spline.fit)
plot(spline.fit$model)
?region.N
load("~/My Distance Projects/d71testing/sim line transect with groups.dat/R/.RData")
12.5+14.5+247.75+172.65+39
x <- seq(1:10)
now <- 5
diff(now, x)
x <- seq(1:10)
now <- 5
diff(now, x)
?diff
diff(now, x, lag=1)
diff(x, now, lag=1)
x
now
diff(x,now)
1-(1-.5)^5
1-(1-.4)^5
1-(1-.3)^5
1-(1-.2)^5
source('~/.active-rstudio-document', echo=TRUE)
setwd("~/GitHub/spermwhaledata/distance_import")
library(rgdal)
# base path
base_path <- "../rawdata/"
## line transects/effort table
# effort data as csv
segs <- readOGR(paste0(base_path, "Analysis.gdb"),"Segment_Centroids")
segs <- as.data.frame(segs)
segs$x <- segs$POINT_X
segs$y <- segs$POINT_Y
segs$Effort <- segs$Length
segs$Sample.Label <- segs$SegmentID
obs <- readOGR(paste0(base_path, "Analysis.gdb"), "Sightings")
obs <- as.data.frame(obs)
obs$distance <- obs$Distance
obs$object <- obs$SightingID
obs$Sample.Label <- obs$SegmentID
obs$size <- obs$GroupSize
hist(obs$distance)
hist(obs$Distance)
